
#include <Atom.hpp>
#include <LinAlg.hpp>
#include <LinAlgTest.h>
// there is still some weird include ordering dependence hidden in
// Declarations.hpp
// clang-format off
#include <Declarations.hpp>
// clang-format on
#include "../systems/wigner_deviation.stan"

#include <main.h>


#ifndef tMPI_3x3_full
#define tMPI_3x3_full
double tMPI_3x3[3][3] = {{0.3376, -0.1788, -0.0822},
                         {0.5377, -0.2657, -0.3201},
                         {0.5685, -0.4798, -0.4556}};
#endif

#ifndef tMPI_5x3_full
#define tMPI_5x3_full
double tMPI_5x3[3][5] = {{0.0157, 0.1084, -0.0426, -0.0367, 0.0036},
                         {0.0974, 0.0444, -0.0240, -0.0499, 0.0029},
                         {-0.0345, 0.0994, 0.1815, -0.0595, 0.0064}};
#endif

#ifndef Ylm_matrix
#define Ylm_matrix 1
std::complex<double> Ylm_M[4] = {
    {0.630783, 0.000000},
    {0.000000, 0.000000},
    {0.096569, 0.000000},
    {-0.259121, -0.149603},
};

#endif

#ifndef SAUPE_SYSTEM
#define SAUPE_SYSTEM
// Saupe Tensor of (+)-IPC in PBDG at 290 K. Analysis done with 20170719.hotfcht
double EulerAngles[3]  = {54.4872796066, 153.9538115629, 120.9997700431};
double EigenVals[3]    = {6.04843366e-05, 5.47333829e-04, -6.07818165e-04};
double EigenVecs[3][3] = {{-4.28933267e-01, -8.74570004e-01, -2.26149420e-01},
                          {8.66578843e-01, -3.27688510e-01, -3.76379262e-01},
                          {2.55063446e-01, -3.57417890e-01, 8.98440366e-01}};
#endif

#ifndef MIN_WIGNER_STEPS
#define MIN_WIGNER_STEPS 40
#endif

#ifndef POLAR_2_EIGEN_COORDINATES
#define POLAR_2_EIGEN_COORDINATES
double Polar2EigenCoordinates[3][5] = {
    {1.5708, .0, 0.9999999999932537, .0, -0.0000036732051},
    {0.7854, 0.785398, 0.4999999999999733, 0.49999983660255, 0.7071068967260},
    {0.4136, -0.869174, 0.2594402531865537, -0.30700610107637,
     0.9156626064924}};
#endif

#ifndef SPHERE_2_B_COORDINATES
#define SPHERE_2_B_COORDINATES
double S2B_B[3][5] = {{-3.74187750e-01, 2.77807858e-01, -7.43160000e-01,
                       -3.94485026e-01, 2.73680654e-01},
                      {7.22376866e-02, 4.16703260e-01, 3.36560094e-01,
                       7.93269104e-01, 2.80341831e-01},
                      {-4.96189906e-01, -8.08117060e-01, 3.05191025e-01,
                       1.56553792e-02, 8.57656188e-02}};

Eigen::Vector3d Sphere_2_B_C1(-1.1734930748, 0.2397338051, 0.4358926811);
Eigen::Vector3d Sphere_2_B_C2(-0.7738365348, 0.6604505451, -1.0005170189);
Eigen::Vector3d Sphere_2_B_C10(-0.4988137048, 2.1671213751, -0.9232293489);
Eigen::Vector3d Sphere_2_B_H2(-1.5867468848, 0.3731674851, -1.6776405989);
Eigen::Vector3d Sphere_2_B_H1(-2.0354668148, 0.8377426551, 0.7533284111);

Eigen::Vector3d Sphere_2_B_C1_H1  = Sphere_2_B_H1 - Sphere_2_B_C1;
Eigen::Vector3d Sphere_2_B_C2_H2  = Sphere_2_B_H2 - Sphere_2_B_C2;
Eigen::Vector3d Sphere_2_B_C10_C2 = Sphere_2_B_C2 - Sphere_2_B_C10;

Eigen::Vector2d Eigen_2_Polar_C1_H1(1.2769752301445, 2.535062262469);
Eigen::Vector2d Eigen_2_Polar_C2_H2(2.2365481867130, -2.801891435198);
Eigen::Vector2d Eigen_2_Polar_C10_C2(1.6212167671661, -1.751345540461);
#endif

#ifndef SV_2_ST_VALUES
#define SV_2_ST_VALUES
// Saupe Vector generated by RDC@hotFCHT.
double SV_2_ST_Vector[5] = {-3.94554405e-04, -2.75218515e-04, -1.14001587e-04,
                            8.08712280e-05, -4.31315036e-04};
// Saupe Tensor generated by RDC@hotFCHT.
double SV_2_ST_Tensor[3][3] = {
    {5.96679451e-05, -1.14001587e-04, 8.08712280e-05},
    {-1.14001587e-04, 3.34886460e-04, -4.31315036e-04},
    {8.08712280e-05, -4.31315036e-04, -3.94554405e-04}};
#endif

#ifndef LINEAR_REGRESSIOON_VALUES
#define LINEAR_REGRESSIOON_VALUES
double linear_regression_x[7] = {0.00, 1.00, 2.00, 3.00, 4.00, 5.00, 6.00};
double linear_regression_y[7] = {0.00, 1.10, 1.90, 3.00, 4.05, 5.05, 5.80};
double linear_regression_m    = 0.9804;
double linear_regression_b    = 0.0446;
double linear_regression_R_2  = 0.9980;
#endif

#ifndef AXB3D_VALUES
#define AXB3D_VALUES
double A_1[3] = {1.0000, 2.0000, 3.0000};
double C_1[3] = {0.0000, 0.0000, 0.0000};
double A_2[3] = {0.8147, 0.9058, 0.1270};
double B_2[3] = {0.9134, 0.6324, 0.0975};
double C_2[3] = {0.0081, 0.0365, -0.3121};  // AxB
double D_2[3] = {-0.0081, -0.0365, 0.3121}; // BxA
#endif

#ifndef S3_PERMUTATIONS
#define S3_PERMUTATIONS
int S3_perm_1[3][3]             = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};
int S3_perm_2[3][3]             = {{0, 1, 0}, {0, 0, 1}, {1, 0, 0}};
int S3_perm_3[3][3]             = {{0, 0, 1}, {1, 0, 0}, {0, 1, 0}};
int S3_perm_4[3][3]             = {{1, 0, 0}, {0, 0, 1}, {0, 1, 0}};
int S3_perm_5[3][3]             = {{0, 0, 1}, {0, 1, 0}, {1, 0, 0}};
int S3_perm_6[3][3]             = {{0, 1, 0}, {1, 0, 0}, {0, 0, 1}};
int S3_permutations[6][3]       = {{0, 1, 2}, {1, 2, 0}, {2, 0, 1},
                             {0, 2, 1}, {2, 1, 0}, {1, 0, 2}};
int S3_permutation_order[6]     = {1, 3, 3, 2, 2, 2};
double S3_permutation_parity[6] = {1.0, 1.0, 1.0, -1.0, -1.0, -1.0};
#endif

#ifndef LEIBNITZ_DERIVATIVE
#define LEIBNITZ_DERIVATIVE
double Grad_1[3][4] = {{0.0000, 0.0000, 0.0000, 0.0000},
                       {0.0000, 0.0000, 0.0000, 0.0000},
                       {1.0249, 1.4826, 1.4826, -3.9901}};

double Grad_2[3][4] = {{3.9903, -1.4826, -1.4827, -1.0250},
                       {-0.0001, 0.0000, 0.0000, 0.0001},
                       {0.0000, 0.0001, -0.0001, 0.0000}};

double Grad_3[3][4] = {{3.9903, 0.5124, 0.5125, -5.0152},
                       {-0.0001, -0.9568, -0.9569, 1.9138},
                       {0.0000, 1.9950, -1.9950, 0.0000}};
#endif

CPPUNIT_TEST_SUITE_REGISTRATION(LinAlgTest);

LinAlgTest::LinAlgTest() {}

void
LinAlgTest::testMoorePenroseInverse()
{
  std::cout << "   - Subrun: Testing 3x3 matrix...\n";
  Eigen::MatrixXd M3x3 = Eigen::MatrixXd::Zero(3, 3);

  M3x3(0, 0) = 2.417;
  M3x3(0, 1) = 3.124;
  M3x3(0, 2) = -2.631;
  M3x3(1, 0) = -4.684;
  M3x3(1, 1) = 7.957;
  M3x3(1, 2) = -4.745;
  M3x3(2, 0) = 7.948;
  M3x3(2, 1) = -4.481;
  M3x3(2, 2) = -0.481;

  Eigen::MatrixXd M3x3_inv = MoorePenroseInverse(M3x3);

  for (int i = 0; i < 3; ++i)
  {
    for (int j = 0; j < 3; ++j)
    {
      CPPUNIT_ASSERT(fabs(M3x3_inv(i, j) - tMPI_3x3[i][j]) < ALLOWED_ERROR);
    }
  }

  std::cout << "   - Subrun: Testint 5x3 matrix...\n";

  Eigen::MatrixXd M5x3 = Eigen::MatrixXd::Zero(5, 3);
  M5x3(0, 0)           = -4.828;
  M5x3(0, 1)           = 9.752;
  M5x3(0, 2)           = -0.182;
  M5x3(1, 0)           = 7.918;
  M5x3(1, 1)           = -1.931;
  M5x3(1, 2)           = 1.293;
  M5x3(2, 0)           = -5.216;
  M5x3(2, 1)           = 1.743;
  M5x3(2, 2)           = 4.341;
  M5x3(3, 0)           = 0.136;
  M5x3(3, 1)           = -3.549;
  M5x3(3, 2)           = -1.287;
  M5x3(4, 0)           = 0.123;
  M5x3(4, 1)           = 0.123;
  M5x3(4, 2)           = 0.123;

  Eigen::MatrixXd M5x3_inv = MoorePenroseInverse(M5x3);
  for (int i = 0; i < 3; ++i)
  {
    for (int j = 0; j < 5; ++j)
    {
      CPPUNIT_ASSERT(fabs(M5x3_inv(i, j) - tMPI_5x3[i][j]) < ALLOWED_ERROR);
    }
  }
}

void
LinAlgTest::testYlm()
{
  CPPUNIT_ASSERT_DOUBLES_EQUAL(
      Ylm_M[0].imag(), Ylm(2, 0, deg2rad(0), deg2rad(0)).imag(), ALLOWED_ERROR);
  CPPUNIT_ASSERT_DOUBLES_EQUAL(
      Ylm_M[0].real(), Ylm(2, 0, deg2rad(0), deg2rad(0)).real(), ALLOWED_ERROR);
  CPPUNIT_ASSERT_DOUBLES_EQUAL(Ylm_M[1].imag(),
                               Ylm(2, 1, deg2rad(0), deg2rad(30)).imag(),
                               ALLOWED_ERROR);
  CPPUNIT_ASSERT_DOUBLES_EQUAL(Ylm_M[1].real(),
                               Ylm(2, 1, deg2rad(0), deg2rad(30)).real(),
                               ALLOWED_ERROR);
  CPPUNIT_ASSERT_DOUBLES_EQUAL(Ylm_M[2].imag(),
                               Ylm(2, 2, deg2rad(30), deg2rad(0)).imag(),
                               ALLOWED_ERROR);
  CPPUNIT_ASSERT_DOUBLES_EQUAL(Ylm_M[2].real(),
                               Ylm(2, 2, deg2rad(30), deg2rad(0)).real(),
                               ALLOWED_ERROR);
  CPPUNIT_ASSERT_DOUBLES_EQUAL(Ylm_M[3].imag(),
                               Ylm(1, 1, deg2rad(60), deg2rad(30)).imag(),
                               ALLOWED_ERROR);
  CPPUNIT_ASSERT_DOUBLES_EQUAL(Ylm_M[3].real(),
                               Ylm(1, 1, deg2rad(60), deg2rad(30)).real(),
                               ALLOWED_ERROR);
}

void
LinAlgTest::testFactorial()
{
  // Suppress the error message for negative values
  std::cerr.setstate(std::ios_base::failbit);
  CPPUNIT_ASSERT_EQUAL(fac(-2), 0.0);
  std::cerr.clear();

  CPPUNIT_ASSERT_EQUAL(fac(0), 1.0);
  CPPUNIT_ASSERT_EQUAL(fac(1), 1.0);
  CPPUNIT_ASSERT_EQUAL(fac(8), 40320.0);
}

void
LinAlgTest::testTensor2Euler()
{
  Eigen::MatrixXd A = Eigen::MatrixXd::Zero(3, 3);
  Eigen::MatrixXd B = Eigen::MatrixXd::Zero(3, 1);
  Eigen::MatrixXd C = Eigen::MatrixXd::Zero(3, 1);

  // Saupe Tensor of (+)-IPC in PBDG at 290 K. Analysis done with
  // 20170719.hotfcht
  A(0, 0) = 3.98682849e-04;
  A(0, 1) = 8.26399721e-05;
  A(0, 2) = 2.87969689e-04;
  A(1, 0) = 8.26399721e-05;
  A(1, 1) = 1.80894842e-05;
  A(1, 2) = 2.83010037e-04;
  A(2, 0) = 2.87969689e-04;
  A(2, 1) = 2.83010037e-04;
  A(2, 2) = -4.16772333e-04;

  Eigen::Vector3d e = rad2deg(Tensor2Euler(A, B, C, 0));

  CPPUNIT_ASSERT(fabs(e(0) - EulerAngles[0]) < ALLOWED_ERROR);
  CPPUNIT_ASSERT(fabs(e(1) - EulerAngles[1]) < ALLOWED_ERROR);
  CPPUNIT_ASSERT(fabs(e(2) - EulerAngles[2]) < ALLOWED_ERROR);

  CPPUNIT_ASSERT(fabs(B(0, 0) - EigenVals[0]) < ALLOWED_ERROR);
  CPPUNIT_ASSERT(fabs(B(1, 0) - EigenVals[1]) < ALLOWED_ERROR);
  CPPUNIT_ASSERT(fabs(B(2, 0) - EigenVals[2]) < ALLOWED_ERROR);
}

void
LinAlgTest::testdd2Mndb()
{
  if (wigner_steps > MIN_WIGNER_STEPS)
    std::cout << "   - Subrun: Test uses analytical and numerical gradient (as "
                 "reference)...\n";

  const int Mmax = 2;
  const int Mmin = -Mmax;
  const int mmax = 2;
  const int mmin = -mmax;
  int M, m, k, i;
  k = 0;

  for (M = Mmin; M <= Mmax; ++M)
  {
    for (m = mmin; m <= mmax; ++m)
      for (i = 0; i < wigner_steps; ++i, ++k)
      {
        CPPUNIT_ASSERT(fabs(dd2Mmdb(M, m, dd_db[k][0]) - dd_db[k][1]) <
                       ALLOWED_ERROR);
        // Numerical derivative at 0 and 90° are relativly poor
        // This should just be tested if enough steps for numerical
        // gradient (obtained by matlab)
        if (wigner_steps > MIN_WIGNER_STEPS && dd_db[k][0] != .0 &&
            dd_db[k][0] >= PI_HALF_)
        {
          CPPUNIT_ASSERT(fabs(dd2Mmdb(M, m, dd_db[k][0]) - dd_db[k][2]) <
                         ALLOWED_NUMERICAL_ERROR);
        }
      }
  }
}

void
LinAlgTest::testSphere2B()
{
  double theta, phi;
  Eigen::MatrixXd result;

  Eigen2Polar(Sphere_2_B_C1_H1, theta, phi);
  result = Sphere2B(theta, phi, .0, .0, .0);
  // for ( int i = 1; i < 2; ++i )
  int i = 4;
  {
    CPPUNIT_ASSERT_DOUBLES_EQUAL(S2B_B[0][i], result(0, i), ALLOWED_ERROR);
  }

  Eigen2Polar(Sphere_2_B_C2_H2, theta, phi);
  result = Sphere2B(theta, phi, .0, .0, .0);
  for (int i = 0; i < 5; ++i)
  {
    //      CPPUNIT_ASSERT ( fabs ( S2B_B[1][i] - result(0,i) ) < ALLOWED_ERROR
    //      ) ;
    CPPUNIT_ASSERT_DOUBLES_EQUAL(S2B_B[1][i], result(0, i), ALLOWED_ERROR);
  }

  Eigen2Polar(Sphere_2_B_C10_C2, theta, phi);
  result = Sphere2B(theta, phi, .0, .0, .0);
  for (int i = 0; i < 5; ++i)
  {
    //      CPPUNIT_ASSERT ( fabs ( S2B_B[2][i] - result(0,i) ) < ALLOWED_ERROR
    //      ) ;
    CPPUNIT_ASSERT_DOUBLES_EQUAL(S2B_B[2][i], result(0, i), ALLOWED_ERROR);
  }
}

void
LinAlgTest::testPolar2Eigen()
{
  Eigen::Vector3d result;

  for (int i = 0; i < 3; ++i)
  {
    result =
        Polar2Eigen(Polar2EigenCoordinates[i][0], Polar2EigenCoordinates[i][1]);
    for (int j = 0; j < 3; ++j)
    {
      result(j) -= Polar2EigenCoordinates[i][(j + 2)];
      CPPUNIT_ASSERT(fabs(result(j)) < ALLOWED_ERROR);
    }
  }
}

void
LinAlgTest::testEigen2Polar()
{
  double theta, phi;
  theta = phi = .0;

  Eigen2Polar(Sphere_2_B_C1_H1, theta, phi);
  CPPUNIT_ASSERT(fabs(theta - Eigen_2_Polar_C1_H1(0)) < ALLOWED_ERROR);
  CPPUNIT_ASSERT(fabs(phi - Eigen_2_Polar_C1_H1(1)) < ALLOWED_ERROR);

  Eigen2Polar(Sphere_2_B_C2_H2, theta, phi);
  CPPUNIT_ASSERT(fabs(theta - Eigen_2_Polar_C2_H2(0)) < ALLOWED_ERROR);
  CPPUNIT_ASSERT(fabs(phi - Eigen_2_Polar_C2_H2(1)) < ALLOWED_ERROR);

  Eigen2Polar(Sphere_2_B_C10_C2, theta, phi);
  CPPUNIT_ASSERT(fabs(theta - Eigen_2_Polar_C10_C2(0)) < ALLOWED_ERROR);
  CPPUNIT_ASSERT(fabs(phi - Eigen_2_Polar_C10_C2(1)) < ALLOWED_ERROR);
}

void
LinAlgTest::testSv2St()
{
  Eigen::MatrixXd SV = Eigen::MatrixXd::Zero(5, 1);
  Eigen::MatrixXd ST = Eigen::MatrixXd::Zero(3, 3);
  int i, j;

  // Normalize : RDC@hotFCHT does not use normalization
  SV(0, 0) = SV_2_ST_Vector[0];
  SV(1, 0) = SV_2_ST_Vector[1] / sqrt(3.0);
  for (i = 2; i < 5; ++i)
    SV(i, 0) = 2.0 * SV_2_ST_Vector[i] / sqrt(3.0);

  for (i = 0; i < 3; ++i)
    for (j = 0; j < 3; ++j)
      ST(i, j) = SV_2_ST_Tensor[i][j];

  Eigen::MatrixXd residue = Sv2St(SV) - ST;
  for (i = 0; i < 3; ++i)
  {
    for (j = i; j < 3; ++j)
      CPPUNIT_ASSERT(fabs(residue(i, j)) < ALLOWED_ERROR);
  }
}

void
LinAlgTest::testlinear_Regression()
{
  int i;
  double LR_m, LR_b, LR_R2;
  Eigen::MatrixXd LR_x = Eigen::MatrixXd::Zero(7, 1);
  Eigen::MatrixXd LR_y = Eigen::MatrixXd::Zero(7, 1);

  for (i = 0; i < 7; ++i)
  {
    LR_x(i, 0) = linear_regression_x[i];
    LR_y(i, 0) = linear_regression_y[i];
  }

  LR_R2 = linear_Regression(LR_x, LR_y, LR_m, LR_b);
  CPPUNIT_ASSERT(fabs(LR_m - linear_regression_m) < ALLOWED_ERROR);
  CPPUNIT_ASSERT(fabs(LR_b - linear_regression_b) < ALLOWED_ERROR);
  CPPUNIT_ASSERT(fabs(LR_R2 - linear_regression_R_2) < ALLOWED_ERROR);
}

void
LinAlgTest::testaxb3d()
{
  double *Result_1  = axb3d(&(A_1[0]), &(A_1[0]));
  double *Result_2  = axb3d(&(A_2[0]), &(B_2[0]));
  double *Result_2i = axb3d(&(B_2[0]), &(A_2[0]));

  for (int axis = 0; axis < NUMBER_OF_AXIS_; ++axis)
  {
    CPPUNIT_ASSERT(fabs(Result_1[axis] - C_1[axis]) < ALLOWED_ERROR);
    CPPUNIT_ASSERT(fabs(Result_2[axis] - C_2[axis]) < ALLOWED_ERROR);
    CPPUNIT_ASSERT(fabs(Result_2i[axis] - D_2[axis]) < ALLOWED_ERROR);
  }
  free(Result_1);
  free(Result_2);
  free(Result_2i);
}

void
LinAlgTest::testS3_permutation_matrix()
{
  int index_1, index_2;
  for (index_1 = 0; index_1 < 3; ++index_1)
  {
    for (index_2 = 0; index_2 < 3; ++index_2)
    {
      CPPUNIT_ASSERT_EQUAL(get_S3_permutation_matrix(1)(index_1, index_2),
                           S3_perm_1[index_1][index_2]);
      CPPUNIT_ASSERT_EQUAL(get_S3_permutation_matrix(2)(index_1, index_2),
                           S3_perm_2[index_1][index_2]);
      CPPUNIT_ASSERT_EQUAL(get_S3_permutation_matrix(3)(index_1, index_2),
                           S3_perm_3[index_1][index_2]);
      CPPUNIT_ASSERT_EQUAL(get_S3_permutation_matrix(4)(index_1, index_2),
                           S3_perm_4[index_1][index_2]);
      CPPUNIT_ASSERT_EQUAL(get_S3_permutation_matrix(5)(index_1, index_2),
                           S3_perm_5[index_1][index_2]);
      CPPUNIT_ASSERT_EQUAL(get_S3_permutation_matrix(6)(index_1, index_2),
                           S3_perm_6[index_1][index_2]);
    }
  }
}

void
LinAlgTest::testS3_permutation_index()
{
  int index, permutation;
  for (index = 0; index < 3; ++index)
  {
    for (permutation = 1; permutation <= 6; ++permutation)
    {
      CPPUNIT_ASSERT_EQUAL(get_S3_permuted_index(permutation, index),
                           S3_permutations[(permutation - 1)][index]);
    }
  }
}

void
LinAlgTest::testS3_permutation_order()
{
  int permutation;
  for (permutation = 1; permutation <= 6; ++permutation)
    CPPUNIT_ASSERT_EQUAL(get_S3_permutation_order(permutation),
                         S3_permutation_order[permutation - 1]);
}

void
LinAlgTest::testS3_permutation_parity()
{
  int permutation;
  for (permutation = 1; permutation <= 6; ++permutation)
    CPPUNIT_ASSERT_EQUAL(
        get_permutation_parity(get_S3_permutation_order(permutation)),
        S3_permutation_parity[permutation - 1]);
}

void
LinAlgTest::testderived_Leibnitz_determinante()
{
  Eigen::Vector3d C1(-0.00006, 0.01213, 0.00002);
  Eigen::Vector3d C2(-0.00006, 1.52781, 0.00002);
  Eigen::Vector3d H1a(-0.97823, -0.51173, 0.00000);
  Eigen::Vector3d H1b(0.97812, -0.51175, 0.00000);
  Eigen::Vector3d H3a(0.00000, 2.05170, -0.97822);
  Eigen::Vector3d H3b(0.00000, 2.05172, 0.97822);

  Eigen::Matrix3d det_1, det_2, det_3;

  det_1.col(0) = (C2 - C1);
  det_1.col(1) = (H1a - C1);
  det_1.col(2) = (H1b - C1);

  det_2.col(0) = (C2 - C1);
  det_2.col(1) = (H3a - C1);
  det_2.col(2) = (H3b - C1);

  det_3.col(0) = (H1a - C1);
  det_3.col(1) = (H3a - C1);
  det_3.col(2) = (H3b - C1);

  for (int i = 0; i < 3; ++i)
  {
    for (int j = 0; j < 4; ++j)
    {
      CPPUNIT_ASSERT(fabs(get_derived_Lebinitz_determinante(det_1, i, j) -
                          Grad_1[i][j]) < ALLOWED_NUMERICAL_ERROR);
      CPPUNIT_ASSERT(fabs(get_derived_Lebinitz_determinante(det_2, i, j) -
                          Grad_2[i][j]) < ALLOWED_NUMERICAL_ERROR);
      CPPUNIT_ASSERT(fabs(get_derived_Lebinitz_determinante(det_3, i, j) -
                          Grad_3[i][j]) < ALLOWED_NUMERICAL_ERROR);
    }
  }
}
