#!/usr/bin/env python3

import sys
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.ticker import LogLocator, NullFormatter
from parse_titania_out import parse_tna_out, ParseInfoTNA

hatch_pattern = ("//", "/", "\\\\", "\\", "+", "o", ".", "O")


def seconda_argument_parser(argv):
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--input",
        "-i",
        nargs="+",
        default=[],
        help="Input file name. This is by default the "
        "<file.tna.out> output file generated by TITANIA.",
        required=True,
    )
    parser.add_argument(
        "--output", "-o", nargs=1, default=None, help="Prefix for the output files.",
    )
    parser.add_argument(
        "--silent",
        "-s",
        action="store_true",
        help="Prevents command line output of plot script.",
    )
    parser.add_argument(
        "--ylimits",
        "-y",
        default="5,105",
        help="Saves the minimal kappa value (-y=<val>) or comma separated "
        "limits for kappa (-y=<val_min>,<val_max>).",
    )
    parser.add_argument(
        "--xlimits",
        "-x",
        default=None,
        help="Saves the minimal eigenvalue (-x=<val>) or comma separated "
        "limits for the eigenvalues (-x=<val_min>,<val_max>).",
    )
    parser.add_argument(
        "--hiderho",
        action="store_true",
        help="Prevents the rho (=l5/l6) gap to be printed.",
    )
    parser.add_argument(
        "--eigenvectors",
        "-e",
        action="store_true",
        help="Plots the eigenvectors of the significant eigenvalues. Significant"
        "are those eigenvalues, that are larger than the (user defined) cutoff.",
    )
    parser.add_argument(
        "--hide_eigen_legend",
        action="store_true",
        help="Hides the legend of the eigenvector plot.",
    )
    parser.add_argument(
        "--align",
        "-a",
        action="store_true",
        help="Aligns the eigenmodes."
    )
    parser.add_argument(
        "--large",
        "-l",
        action="store_true",
        help="Increases the font size."
    )
    return parser.parse_args(argv)


def get_tics(tnadat, args):
    if args.xlimits is not None:
        cutoff = float(args.xlimits.split(",")[0])
        upper_lim = (
            0.0
            if len(args.xlimits.split(",")) == 1
            else float(args.xlimits.split(",")[1])
        )
        for set in tnadat:
            if set["SECONDA"]["SECONDA"][0]["EigVal"] > upper_lim:
                eval = set["SECONDA"]["SECONDA"][0]["EigVal"]
                upper_lim = np.power(
                    10, int(float("{:.0f}".format(np.log10(eval))) + 1)
                )
        xtics_minor = int(np.log10(upper_lim / cutoff)) + 1
    else:
        upper_lim = 0.0
        for set in tnadat:
            if set["SECONDA"]["SECONDA"][0]["EigVal"] > upper_lim:
                eval = set["SECONDA"]["SECONDA"][0]["EigVal"]
                cutoff = set["SECONDA"]["Cutoff"]
                upper_lim = np.power(
                    10, int(float("{:.0f}".format(np.log10(eval))) + 1)
                )
                xtics_minor = int(np.log10(upper_lim / cutoff)) + 1
    xtics_major = int(xtics_minor / 2)

    return upper_lim, cutoff, xtics_major, xtics_minor


def handle_plots(tnafiledata, plot_info, args):
    if args.large:
        font = {'weight' : 'bold',
                'size'   : 22}
        plt.rc('font', **font)
    plot_info["num_eig_vals"] = handle_seconda_plots(tnafiledata, plot_info, args)
    if args.eigenvectors:
        handle_eigenvector_plots(tnafiledata, plot_info, args)


def handle_seconda_plots(tnafiledata, plot_info, args):
    num_eig_vals = 0
    # Prepare SECONDA eigenvalue plot
    fig, axis = plt.subplots()
    fig.set_size_inches(11.69, 8.27)

    # Set labels
    plt.xlabel(r"Eigenvalue $\lambda$ / Hz$^2$", weight="bold")
    plt.ylabel(r"Collectivity $\kappa$ / %", weight="bold")

    # Set limits and generate grid
    plt.xlim((plot_info["xlim"][0], plot_info["xlim"][1]))
    plt.ylim((plot_info["ylim"][0], plot_info["ylim"][1]))
    plt.xscale("log")

    axis.xaxis.set_major_locator(LogLocator(base=10, numticks=plot_info["xtics_major"]))
    locmin = LogLocator(
        base=10.0,
        subs=(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0),
        numticks=plot_info["xtics_minor"],
    )
    axis.xaxis.set_minor_locator(locmin)
    axis.xaxis.set_minor_formatter(NullFormatter())
    plt.grid(True, which="minor")
    plt.grid(which="major", axis="both", color="grey", alpha=0.5, linestyle="--")
    plt.grid(which="minor", axis="x", color="grey", alpha=0.1, linestyle="--")
    
    point_size = 12 if args.large else 7

    # Plot rho
    if len(tnafiledata) == 1:
        props = dict(boxstyle="round", facecolor="white", alpha=0.5)
        plt.text(
            plot_info["xlim"][0] * 5,
            0.95 * plot_info["ylim"][1] + 0.05 * plot_info["ylim"][0],
            plot_info["out_text"],
            fontsize=14,
            verticalalignment="top",
            bbox=props,
        )

    for idx, data in enumerate(tnafiledata):
        data["eig_vals"] = plot_seconda_data(
            data, axis, plot_info["ylim"], hatch_pattern[idx], args.hiderho, point_size
        )
        num_eig_vals = (
            (len(data["eig_vals"]) - 1)
            if len(data["eig_vals"]) > num_eig_vals
            else num_eig_vals
        )

    plt.legend(loc="upper right", fontsize=14)
    # Plot, save and finish
    if args.output is None:
        fig.savefig("seconda.pdf", bbox_inches="tight")
    else:
        fig.savefig("".join([args.output[0], ".sec.pdf"]), bbox_inches="tight")
    return num_eig_vals


def handle_eigenvector_plots(tnafiledata, plot_info, args):
    num_modes = plot_info["num_eig_vals"] if plot_info["num_eig_vals"] >= 5 else 5
    plot_info["rows"] = 5
    plot_info["cols"] = int(num_modes / plot_info["rows"]) + (1 if num_modes > 5 else 0)
    fig, ax = plt.subplots(plot_info["rows"], plot_info["cols"])
    fig.set_size_inches(1.27 + 7 * plot_info["cols"], 11.69)
    
    
    if args.align:
        rdc_template=[]
        for data in tnafiledata:
            rdc_template=rdc_template + list(set(data["RDCs"]) - set(rdc_template))
        rdc_template.sort()
        plot_info["rdc_template"]=rdc_template

    for data in tnafiledata:
        plot_eigenvectors(data, ax, num_modes, plot_info)
    fig.tight_layout()
    fig.savefig("eigvecs.pdf", bbox_inches="tight")

def align_eigenmodes(mode, rdcs, template):
    new_mode=np.zeros(len(template))
    for idx, rdc in enumerate(template):
        if rdc in rdcs:
            new_mode[idx]=mode[rdcs.index(rdc)]
        else:
            new_mode[idx]=None
    return new_mode

def plot_eigenvectors(tnafiledata, ax, num_modes, plot_info):
    xlim = plot_info["xlim"]
    eig_val = tnafiledata["eig_vals"]
    eig_vec = tnafiledata["SECONDA"]["Eigenmodes"]
    props = dict(boxstyle="round", facecolor="white", alpha=0.5)

    for idx_m, mode in enumerate(eig_vec):
        for idx_e, element in enumerate(mode):
            eig_vec[idx_m][idx_e] = element * element

    if plot_info["cols"] > 1:
        for col in range(plot_info["cols"]):
            for row in range(plot_info["rows"]):
                idx = col * 5 + row
                if plot_info["align"]:
                    mode=align_eigenmodes(eig_vec[idx], tnafiledata["RDCs"], plot_info["rdc_template"])
                else:
                    mode = eig_vec[idx]
                if idx == 0:
                    legend="".join([tnafiledata["Title"], " ($\lambda$[", str(idx), "]): ", str(tnafiledata["SECONDA"]["SECONDA"][idx]["EigVal"])])
                elif idx < (len(tnafiledata["SECONDA"]["SECONDA"]) - 1):
                    legend="".join(["$\lambda$[", str(idx), "]: ", str(tnafiledata["SECONDA"]["SECONDA"][idx]["EigVal"])])
                else:
                    legend="".join(["$\lambda$[", str(idx), "]: <", str(plot_info["xlim"][0])])
                ax[row, col].plot(mode, 'o-', linewidth=1, markersize=4,label=legend)
                ax[row, col].text(
                    0.01,
                    0.95,
                    "".join(["Eigenmode ", str(idx + 1)]),
                    transform=ax[row, col].transAxes,
                    fontsize=14,
                    verticalalignment="top",
                    horizontalalignment="left",
                    bbox=props,
                )
                ax[row, col].set_ylabel("$|q_i>^2$")
                ax[row, col].set_xlabel("RDC index i")
                ax[row, col].set_xlim((0, len(mode) - 1))
                if not plot_info["hide_eigen_legend"]:
                    ax[row, col].legend(loc="upper right", fontsize=14)

    else:
        for row in range(plot_info["rows"]):
            idx = row
            if plot_info["align"]:
                mode=align_eigenmodes(eig_vec[idx], tnafiledata["RDCs"], plot_info["rdc_template"])
            else:
                mode = eig_vec[idx]
            if idx == 0:
                legend="".join([tnafiledata["Title"], " ($\lambda$[", str(idx), "]): ", str(tnafiledata["SECONDA"]["SECONDA"][idx]["EigVal"])])
            elif idx < (len(tnafiledata["SECONDA"]["SECONDA"]) - 1):
                legend="".join(["$\lambda$[", str(idx), "]: ", str(tnafiledata["SECONDA"]["SECONDA"][idx]["EigVal"])])
            else:
                legend="".join(["$\lambda$[", str(idx), "]: <", str(plot_info["xlim"][0])])
            ax[row].plot(mode, 'o-', linewidth=1, markersize=4,label=legend)
            ax[row].text(
                0.01,
                0.95,
                "".join(["Eigenmode ", str(idx + 1)]),
                transform=ax[row].transAxes,
                fontsize=14,
                verticalalignment="top",
                horizontalalignment="left",
                bbox=props,
            )
            ax[row].set_ylabel("$|q_i>^2$")
            ax[row].set_xlabel("RDC index i")
            ax[row].set_xlim((0, len(mode) - 1))
            if not plot_info["hide_eigen_legend"]:
                ax[row].legend(loc="upper right", fontsize=14)


    return 0


def plot_seconda_data(tnafiledata, axis, ylim, hatch_pat, hiderho, point_size):
    eig_val = []
    kappa = []
    cum_sum = []

    for seconda_point in tnafiledata["SECONDA"]["SECONDA"]:
        eig_val.append(seconda_point["EigVal"])
        kappa.append(seconda_point["Kappa"])
        cum_sum.append(seconda_point["csum"])

    (line,) = axis.plot(eig_val, kappa, ".", label=tnafiledata["Title"], markersize=point_size)
    if not hiderho:
        idx_max = 4 if len(eig_val) > 5 else len(eig_val) - 1
        min = 0 if len(eig_val) < 6 else eig_val[5]
        plt.fill_between(
            [eig_val[idx_max], min],
            ylim[0],
            ylim[1],
            alpha=0.0,
            color=line.get_color(),
            hatch=hatch_pat,
        )
    return eig_val


def main(argv):
    args = seconda_argument_parser(argv)

    tnafiledata = []
    for input in args.input:
        tnafiledata.append(parse_tna_out(input, args.silent, ParseInfoTNA("SECONDA","RDCs")))

    ylim = [
        float(args.ylimits.split(",")[0]),
        105.0
        if len(args.ylimits.split(",")) == 1
        else float(args.ylimits.split(",")[1]),
    ]

    if len(tnafiledata) == 1:
        # Calculate additional parameters
        rho = (
            "undefined"
            if len(tnafiledata[0]["SECONDA"]["SECONDA"]) < 6
            or (
                tnafiledata[0]["SECONDA"]["SECONDA"][5]["EigVal"]
                == tnafiledata[0]["SECONDA"]["Cutoff"]
                and tnafiledata[0]["SECONDA"]["SECONDA"][5]["EigVal"] == 0
            )
            else tnafiledata[0]["SECONDA"]["SECONDA"][4]["EigVal"]
            / tnafiledata[0]["SECONDA"]["SECONDA"][5]["EigVal"]
        )
        out_text = "$\\lambda_1/\\lambda_5$={:.2e}\n$\\lambda_5/\\lambda_6$={}".format(
            (
                tnafiledata[0]["SECONDA"]["SECONDA"][0]["EigVal"]
                / tnafiledata[0]["SECONDA"]["SECONDA"][4]["EigVal"]
            ),
            rho,
        )

    upper_lim, cutoff, xtics_major, xtics_minor = get_tics(tnafiledata, args)
    plot_info = {
        "xlim": [cutoff, upper_lim],
        "xtics_major": xtics_major,
        "xtics_minor": xtics_minor,
        "ylim": ylim,
        "out_text": out_text if "out_text" in locals() else None,
        "hide_eigen_legend": args.hide_eigen_legend,
        "align": args.align,
    }
    handle_plots(tnafiledata, plot_info, args)

    plt.close()


if __name__ == "__main__":
    main(sys.argv[1:])
