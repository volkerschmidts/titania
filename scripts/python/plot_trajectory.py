#!/usr/bin/env python3

import sys
import numpy as np
import matplotlib.pylab as plt
import numpy as np

from time import sleep
from parse_titania_out import parse_tna_out, ParseInfoTNA


def trajectory_argument_parser(argv):
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--input",
        "-i",
        nargs=1,
        default=None,
        help="Input file name. This is by default the "
        "<file.tna.out> output file generated by TITANIA.",
        required=False,
    )
    parser.add_argument(
        "--output", 
        "-o", 
        nargs=1, 
        default=None, 
        help="Prefix for the output files.",
    )
    parser.add_argument(
        "--silent",
        "-s",
        action="store_true",
        help="Prevents command line output of plot script.",
    )
    parser.add_argument(
        "--hold",
        "-H",
        action="store_true",
        help="Keeps the matplotlib window open.",
    )
    parser.add_argument(
        "--xlimits",
        "-x",
        default=None,
        help="Saves the minimal eigenvalue (-x=<val>) or comma separated "
        "limits for the eigenvalues (-x=<val_min>,<val_max>).",
    )
    parser.add_argument(
        "--centers",
        "-c",
        default=None,
        help="Comma separated list of centers that should be plotted in the trajectory."
        "--centers=<Center_1>[,<Center_2>,...].",
    )
    parser.add_argument(
        "--plotdistribution",
        "-p",
        action="store_true",
        help="Enables the bar plot of the chiral volume distribution.",
    )
    parser.add_argument(
        "--large",
        "-l",
        action="store_true",
        help="Increases the font size."
    )
# The inset keyword might work with some more efford.
# Currently the plots are just to small to handle an
# inset with an reasonable size.
#    parser.add_argument(
#        "--inset",
#        "-I",
#        default=None,
#        help="Generates a inset in the respective plots. Define either "
#        "--insert=<x_min> or --insert=<x_min>,<x_max> of the requested range."
#    )
    return parser.parse_args(argv)

def load_limits(tnafiledata, args):
    if args.xlimits is None:
        xlim=[0,tnafiledata["Iteration"]]
    else:
        lim = args.xlimits.split(",")
        xlim=[int(lim[0]), int(lim[1]) if len(lim) > 1 else tnafiledata["Iteration"]]
    return xlim

def plot_trajectory(tnafiledata, args, xlim):
    iter=np.linspace(xlim[0], xlim[1], (xlim[1]-xlim[0]))
    chiral_volumes=tnafiledata["ChiralVolume"]
    stop_criteria=tnafiledata["StopCrit"]["Values"]

    fig,ax=plt.subplots(3,1)
    fig.set_size_inches(8.27,11.69)
    ax[0].semilogy(iter, stop_criteria["SaupeMean"][xlim[0]:xlim[1]],    label="rmsd(S)")
    ax[0].semilogy(iter, stop_criteria["SaupeSigma"][xlim[0]:xlim[1]],   label="rmsd(sig[S])")
    ax[0].semilogy(iter, stop_criteria["PolarMean"][xlim[0]:xlim[1]],    label="rmsd(p)")
    ax[0].semilogy(iter, stop_criteria["PolarSigma"][xlim[0]:xlim[1]],   label="rmsd(sig[p])")
    ax[0].semilogy(iter, stop_criteria["VectorLength"][xlim[0]:xlim[1]], label="rmsd(R)")
    ax[0].set_title("Monte-Carlo $rmsd$s", fontweight = "bold")
    ax[0].set_ylabel("$rmsd(i)$")
    ax[0].set_xlim(xlim)
    ax[0].legend(loc=(1.05,0.0), fontsize=12)#, bbox_to_anchor=(2.0, 0.5))
    ax[1].plot(iter, tnafiledata["Soverall"][xlim[0]:xlim[1]])
    ax[1].set_xlim(xlim)
    ax[1].set_ylim([0,1.05])
    ax[1].set_title("$S_{overall}$", fontweight = "bold")
    ax[1].set_ylabel("$S_{overall}$")
    for center in args.centers.split(","):
        ax[2].plot(iter, chiral_volumes["Volumes"][center][xlim[0]+1:xlim[1]+1], label=center)
    ax[2].set_title("Chiral volumes $\AA^3$", fontweight = "bold")
    ax[2].set_xlim(xlim)
    ax[2].set_xlabel("Iteration", fontweight = "bold")
    ax[2].set_ylabel("$V_c / \AA^3$")
    num_col=(1 if len(args.centers.split(",")) <=6 else int(len(args.centers.split(","))/5)+1)
    ax[2].legend(loc=(1.05,0.0), fontsize=12, ncol=num_col)
    fig.tight_layout()
    if args.output is None:
        fig.savefig("trajectory.pdf", bbox_inches="tight")
    else:
        fig.savefig("".join([args.output[0], ".trj.pdf"]), bbox_inches="tight")

def plot_distribution(tnafiledata, vc_stat, args, xlim):
    lw=3.5 if args.large else 2
    binsize=0.1
    req_centers=args.centers.split(",")
    chiral_volumes=tnafiledata["ChiralVolume"]
    props = dict(boxstyle='round', facecolor='white', alpha=0.5)
    fig,ax=plt.subplots(len(req_centers),1, constrained_layout=True)
    ysize=2.5*len(req_centers)+1.69
    fig.set_size_inches(8.27,ysize)
    for idx,center in enumerate(req_centers):
        median=vc_stat[center]["median"]
        mean=vc_stat[center]["mean"]
        wmean=vc_stat[center]["it-mean"]
        last=chiral_volumes["Volumes"][center][-1]
        ax[idx].hist(chiral_volumes["Volumes"][center][xlim[0]+1:xlim[1]+1], bins=np.arange(-1, 1 + binsize, binsize), color=(0.016, 0.353, 0.745, 0.500))#, label=center)
        ylim=ax[idx].get_ylim()
        ax[idx].text(0.98, 0.95, center, transform=ax[idx].transAxes, fontsize=14, verticalalignment='top', horizontalalignment='right', bbox=props)
        pos=0.40*ylim[1]
        delta=(ylim[0]-ylim[1])*0.02
        err=vc_stat[center]["rmsd"]
        ax[idx].plot([ last, last], ylim, label="last",       color=(0.302,0.302,0.302), linewidth=lw)
        ax[idx].plot([ last-err, last+err], [pos,pos],        color=(0.302,0.302,0.302), linewidth=lw)
        ax[idx].plot([ last+err, last+err], [pos+delta,pos-delta], color=(0.302,0.302,0.302), linewidth=lw)
        ax[idx].plot([ last-err, last-err], [pos+delta,pos-delta], color=(0.302,0.302,0.302), linewidth=lw)
        ax[idx].plot([ median, median], ylim, label="median", color=(0.000,0.427,0.173), linewidth=lw)
        pos=0.50*ylim[1]
        err=vc_stat[center]["stdev"]
        ax[idx].plot([ mean, mean], ylim, label="mean",       color=(0.702,0.000,0.000), linewidth=lw)
        ax[idx].plot([ mean-err, mean+err], [pos,pos],        color=(0.702,0.000,0.000), linewidth=lw)
        ax[idx].plot([ mean+err, mean+err], [pos+delta,pos-delta], color=(0.702,0.000,0.000), linewidth=lw)
        ax[idx].plot([ mean-err, mean-err], [pos+delta,pos-delta], color=(0.702,0.000,0.000), linewidth=lw)
        pos=0.60*ylim[1]
        err=vc_stat[center]["it-stdev"]
        ax[idx].plot([ wmean, wmean], ylim, label="w. mean",    color=(0.016,0.353,0.553), linewidth=lw)
        ax[idx].plot([ wmean-err, wmean+err], [pos,pos],        color=(0.016,0.353,0.553), linewidth=lw)
        ax[idx].plot([ wmean+err, wmean+err], [pos+delta,pos-delta], color=(0.016,0.353,0.553), linewidth=lw)
        ax[idx].plot([ wmean-err, wmean-err], [pos+delta,pos-delta], color=(0.016,0.353,0.553), linewidth=lw)
        ax[idx].set_ylabel("Counts", fontweight="bold")
        ax[idx].set_xlim((-1.05,1.05))
    ax[idx].set_xlabel("Chiral volume $V_c$ / ${\AA}$", fontweight="bold")
    ax[idx].legend(loc='lower center', 
                   bbox_to_anchor=(0.5, -0.70),  # 2: 0.35, 3: 0.55, 4: 0.80, 5: 1.25
                   ncol=4, 
                   fontsize=18)
    ax[0].set_title("Distribution of chiral volumes", fontweight="bold")
    #fig.tight_layout()

    if args.output is None:
        fig.savefig("chiral_volume_distribution.pdf")#, bbox_inches="tight")
    else:
        fig.savefig("".join([args.output[0], ".vcd.pdf"]), bbox_inches="tight")

def vc_statistics(tnafiledata, args, xlim):
    stat=dict()
    chiral_volumes=tnafiledata["ChiralVolume"]
    iter=tnafiledata["Iteration"]
    fifty_percent=int(iter/2)
    for idx, center in enumerate(args.centers.split(",")):
        ccenter={"mean": 0.0, "stdev": 0.0, "it-mean": 0.0, "it-stdev": 0.0, "50-mean": 0.0, "50-stdev": 0.0}
        ccenter["mean"]=np.average(chiral_volumes["Volumes"][center])
        ccenter["stdev"]=np.std(chiral_volumes["Volumes"][center])
        ccenter["50-mean"]=np.average(chiral_volumes["Volumes"][center][fifty_percent:])
        ccenter["50-stdev"]=np.std(chiral_volumes["Volumes"][center][fifty_percent:])
        ccenter["it-mean"]=np.average(chiral_volumes["Volumes"][center][xlim[0]:xlim[1]], weights=np.linspace(xlim[0], xlim[1], (xlim[1]-xlim[0])))
        ccenter["it-stdev"]=np.sqrt(np.cov(chiral_volumes["Volumes"][center][xlim[0]:xlim[1]], aweights=np.linspace(xlim[0], xlim[1], (xlim[1]-xlim[0]))))
        ccenter["median"]=np.median(chiral_volumes["Volumes"][center][xlim[0]:xlim[1]])
        ccenter["rmsd"]=chiral_volumes["Analysis"][center]
        stat[center]=ccenter
        if not args.silent:
            print("Statistics of center {}".format(center))
            print("Final chiral volume:                   {:7.4} +- {:.4}".format(tnafiledata["ChiralVolume"]["Volumes"][center][-1], ccenter["rmsd"]))
            print("Mean chiral volume:                    {:7.4} +- {:.4}".format(ccenter["mean"], ccenter["stdev"]))
            print("Mean chiral volume of last 50%:        {:7.4} +- {:.4}".format(ccenter["50-mean"], ccenter["50-stdev"]))
            print("Mean chiral volume iteration weighted: {:7.4} +- {:.4}".format(ccenter["it-mean"], ccenter["it-stdev"]))
            print("Median of chiral volumes:              {:7.4} ".format(ccenter["median"]))
    return stat

def main(argv):
    args = trajectory_argument_parser(argv)
    if args.large == False:
        print('The script \'plot_trajectory.py\' is optimized for the usage')
        print('of the argument -l.')

    tnafiledata = parse_tna_out(args.input[0], True, ParseInfoTNA("StopCrit","chiralVolume"))
    if args.centers is None:
        args.centers = ",".join(tnafiledata["ChiralVolume"]["Centers"])
    xlim=load_limits(tnafiledata, args)
    vc_stat=vc_statistics(tnafiledata, args, xlim)
    if args.large:
        font = {'weight' : 'bold',
                'size'   : 22}
        plt.rc('font', **font)
    plot_trajectory(tnafiledata, args, xlim)
    if args.plotdistribution:
        plot_distribution(tnafiledata, vc_stat, args, xlim)
    if args.hold:
        plt.show()


if __name__ == "__main__":
    main(sys.argv[1:])
